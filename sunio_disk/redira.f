      SUBROUTINE REDIRA(ILR, LAO, NWD, I2FLAG, LUN, NLREC, ISTAT)
C
C SUN-UNIX VERSION, RECL=512 BYTES.
C
C READS BINARY VARIABLE-LENGTH DISK FILE RECORDS IN RANDOM ORDER
C IF REQUIRED.  THE FILE READ BY REDIRA MUST HAVE BEEN WRITTEN BY
C SUBROUTINE WRDIRA;  IT IS SUN, PC-LINUX AND VAX COMPATIBLE.  THE DATA
C IS WRITTEN IN SUN ORDER AND TRANSLATED TO DEC ORDER FOR VAX OR PC
C ROUTINES.
C   ILR - LOGICAL RECORD NO.  CALLING REDIRA WITH ILR = 0 IS A
C         SPECIAL CASE WHICH INITIALIZES THE ROUTINE AND RETURNS
C         A HEADER RECORD IN LAO IF PRESENT.  REDIRA MUST BE
C         CALLED WITH ILR = 0 INITIALLY.
C   LAO - RECORD IS RETURNED IN ARRAY LAO, DATA TYPE OF LAO MUST
C         AGREE (USE EQUIVALENCE) IF GNU FORTRAN (LINUX).
C   NWD - NO. OF WORDS TRANSFERED TO LAO.
C   I2FLAG - INPUT FLAG;  =0, DATA IS REAL OR INTEGER*4, NWD IS THE
C            NO. OF 4-BYTE WORDS.
C            =1, DATA IS INTEGER*2, NWD IS THE NO. OF 2-BYTE WORDS.
C            INTEGER*2 DATA MUST ALWAYS HAVE AN EVEN NO. OF WORDS
C            DIMENSIONED.
C   LUN - LOGICAL UNIT NO. WHICH MUST HAVE A DIRECT ACCESS FILE OPEN
C         WITH RECL=512 BYTES.  USE RECL=128 4-BYTE WORDS FOR DEC.
C   NLREC - RETURNED NO. OF LOGICAL RECORDS IN THE FILE.
C   ISTAT - RETURNED STATUS,  =0, OK.  =1, END-OF-FILE.
C           =-1, DISK ERROR.
C
      SAVE LBUF, LPOIN, IRECD, NRIF, IRECP, IBNP, LUNC, ILPT,
     1 KSAV, JLPT
      DIMENSION LAO(*), LBUF(128,8), LPOIN(128,8), KSAV(8,5)
      INTEGER*2 IPOIN(256,8)
      EQUIVALENCE (LPOIN,IPOIN)
      ISTAT = 0
      IF(ILR.NE.0.AND.LUN.NE.LUNC) THEN
C SAVE OLD CONTEXT, RESTORE NEW.
        DO 5 I=1,ILPT         !FIND NEW POINTER.
        IF(KSAV(I,5).EQ.LUN) IRE = I
    5   CONTINUE
        ISV = JLPT
C SAVE OLD LUNC VALUES.
        KSAV(ISV,1) = IRECD
        KSAV(ISV,2) = NRIF
        KSAV(ISV,3) = IRECP
        KSAV(ISV,4) = IBNP
C RESTORE NEW LUN VALUES.
        IRECD = KSAV(IRE,1)
        NRIF = KSAV(IRE,2)
        IRECP = KSAV(IRE,3)
        IBNP = KSAV(IRE,4)
        JLPT = IRE
        LUNC = LUN
      ENDIF
      IF(ILR.LE.0) THEN
C
C***** INITIALIZATION, GET POINTERS, PASS HEADER.
        IRECY = 0                  !RECYCLE POINTERS IF POSSIBLE.
        IF(ILPT.EQ.0) GO TO 7
        DO 6 I=1,ILPT
        IF(KSAV(I,5).NE.LUN) GO TO 6
        JLPT = I
        IRECY = 1
        GO TO 9
    6   CONTINUE
    7   JLPT = ILPT + 1
    9   IRECD = 1
        READ(LUN, REC=IRECD) (LBUF(L,JLPT),L=1,128)
C REORDER BYTES, 1,2,3,4 = 4,3,2,1
CC        CALL REBYTE(LBUF(1,JLPT), 2)
C BLOCK NO. FOR RECORD POINTERS.
        IBNP = LBUF(1,JLPT)
        NI2W = LBUF(2,JLPT)
C NO. 4-BYTE WORDS IN HEADER
        NWIH = (NI2W + 1)/2
C LBUF POINTER.
        LBP = 3
        IF(NWIH.LE.0) GO TO 22
C TRANSFER HEADER.
        DO 20 I=1,NWIH
        IF(LBP.GT.128) THEN
          IRECD = IRECD + 1
          READ(LUN, REC=IRECD) (LBUF(L,JLPT),L=1,128)
          LBP = 1
        ENDIF
        LAO(I) = LBUF(LBP,JLPT)
        LBP = LBP + 1
   20   CONTINUE
        IF(I2FLAG.EQ.0) THEN
CC          CALL REBYTE(LAO, NWIH)
          NWD = NWIH
        ELSE
CC          CALL RESWAB(LAO, NI2W)
          NWD = NI2W
        ENDIF
C READ 1ST BLOCK OF POINTERS.
   22   READ(LUN, REC=IBNP) (LPOIN(L,JLPT),L=1,128)
CC        CALL REBYTE(LPOIN(1,JLPT), 128)
C NO. OF BLOCKS IN DISK FILE.
        NBIF = LPOIN(1,JLPT)
C NO. OF LOGICAL RECORDS IN DISK FILE.
        NRIF = LPOIN(2,JLPT)
        NLREC = NRIF
        IRECP = IBNP
        KSAV(JLPT,1) = IRECD
        KSAV(JLPT,2) = NRIF
        KSAV(JLPT,3) = IRECP
        KSAV(JLPT,4) = IBNP
        KSAV(JLPT,5) = LUN
        LUNC = LUN
        IF(IRECY.EQ.0) ILPT = JLPT
      ELSE
C
C***** TRANSFER LOGICAL RECORDS, MAY BE ACCESSED IN RANDOM ORDER.
C
        IF(ILR.GT.NRIF) GO TO 32     !TEST FOR "EOF".
C LOGICAL RECORD POINTER ADDRESS IN POINTER BLOCKS.
        IPOIA = ILR*2 + 1
C POINTER BLOCK HAVING ADDRESS.
        NRECP = (IPOIA - 1)/128 + IBNP
C WORD IN POINTER BLOCK HAVING ADDRESS.
        IWDPB = MOD(IPOIA-1, 128) + 1
        IF(IRECP.NE.NRECP) THEN
C READ A POINTER BLOCK IF NOT PRESENT.
          IRECP = NRECP
          READ(LUN, REC=IRECP) (LPOIN(L,JLPT),L=1,128)
CC          CALL REBYTE(LPOIN(1,JLPT), 128)
        ENDIF
C DATA BLOCK HAVING START OF RECORD DESIRED, ILR.
        NRECD = LPOIN(IWDPB,JLPT)
        INT = (IWDPB + 1)*2
C NO. OF I*2 WORDS IN LOGICAL REC.
CC REVERSE INT & INT-1 FOR WINDOWS,DEC, OR PC-LINUX.
        NWIR = IPOIN(INT,JLPT)
C POINTER IN BLOCK TO START OF LOGICAL RECORD.
        IPIB = IPOIN(INT-1,JLPT)
        IF(IRECD.NE.NRECD) THEN
C READ A DATA BLOCK IF NOT PRESENT.
          IRECD = NRECD
          READ(LUN, REC=IRECD) (LBUF(L,JLPT),L=1,128)
        ENDIF
        INEX = IPIB
C NO. IF REAL WORDS IN LOGICAL RECORD.
        NI4W = (NWIR + 1)/2
C TRANSFER DATA TO ARRAY ILR.
        DO 30 I=1,NI4W
        IF(INEX.GT.128) THEN
C READ A DATA BLOCK IF NOT PRESENT.
          IRECD = IRECD + 1
          READ(LUN, REC=IRECD) (LBUF(L,JLPT),L=1,128)
          INEX = 1
        ENDIF
        LAO(I) = LBUF(INEX,JLPT)
        INEX = INEX + 1
   30   CONTINUE
        IF(I2FLAG.EQ.0) THEN
C REORDER BYTES FOR REAL OR INTEGER*4.
CC          CALL REBYTE(LAO, NI4W)
          NWD = NI4W
        ELSE
C SWAP BYTES FOR INTEGER*2.
CC          CALL RESWAB(LAO, NWIR)
          NWD = NWIR
        ENDIF
        NLREC = NRIF
      ENDIF
      GO TO 50
C "EOF", RETURN STATUS.
   32 ISTAT = 1
      NLREC = NRIF
      GO TO 50
C SOME KIND OF DISK ERROR.
   40 ISTAT = -1
   50 RETURN
      END
